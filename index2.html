<!DOCTYPE html>
<html>
<head></head>
<body>

  <!-- Automatic image classification/labeling webapp -->
  <!-- https://js.tensorflow.org/api/1.0.0/ -->
  <h1 style='text-align: center; margin-bottom: -35px;'>CodeSolution2 - Image labeling webapp: Read files from URL and output label</h1>
  <br><br>
        <button id="run_mobilenet_way1" onclick="run_mobilenet_way1()" style="display:block">run_mobilenet_way1</button>
	<br>
	
<div id="output" style="font-family:courier;font-size:24px;height:300px"></div>
  
<style>canvas {border: 1px solid black; position: relative; z-index: 1;}
div {position: relative; z-index: 2;}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0"></script>

<script>

  // -------------------------------------------------
	
  const outp = document.getElementById('output');

  var url_vec = [];


  // -------------------------------------------------
	
async function get_urls_from_repo() {
	
  try {
	  
    const repoOwner = 'CodeSolutions2';
    const repoName = 'test_4_webapps';
    var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;
    //var options = {method : 'get', headers: headers, mode: 'no-cors'};
    await fetch(url).then(res => res.json()).then(data => {

    data.forEach(file => {
      if (file.type === 'file' && file.name.match(/.(jpg|jpeg|png|gif)$/i)) {
        
        //outp.innerHTML += "Filename=" + file.name + ", file url=" + file.download_url + "<br/>";
	url_vec.push(file.download_url);
      }
    });
  }).catch(error => { outp.innerHTML += error; });

  } catch (error) {
    outp.innerHTML = error;
  }

	return url_vec;
}


  // -------------------------------------------------

function create_dynamic_canvasElement() {
	
	// Create a canvas element
	var canvasElement = document.createElement('canvas');

	// Set the width and height of the canvas
	canvasElement.width = 224;
	canvasElement.height = canvasElement.width;
	      
	// Get the 2D rendering context of the canvas
	var ctx = canvasElement.getContext("2d");
	      
	// Add the canvas to the document body or any other desired element
	document.body.appendChild(canvasElement);

	return ctx;
}


  // -------------------------------------------------
	

//async function load_model(){

	// Did not work
 	// model = await mobilenet.load().then(model => { return model });
	// OR
	//return await mobilenet.load();
//}
//const model = load_model();
	//TypeError: model.classify is not a function
	
  // -------------------------------------------------

  async function run_mobilenet_way1() {

    var url_vec = await get_urls_from_repo();

    // PRINT
    outp.innerHTML += 'url_vec: ' + url_vec + "<br/>";
	  
    // Load the model
    await mobilenet.load().then(model => {

    var pred_vec = [];
	    
    url_vec.forEach(function(url, index) {
        
        // ---------------------------
        // Create a canvas for first image
	var ctx = create_dynamic_canvasElement();
	
	// ---------------------------
        
	const image = new Image();

        // Add 'crossorigin' attribute to bypass insecure error
        image.crossOrigin = "anonymous";

        // PRINT
        // outp.innerHTML += 'image.complete: ' + image.complete + "<br/>";

        image.onload = async () => {
	
		        // Draw image on canvas
		        // canvasElement.style.display = "block";
		        ctx.drawImage(image, 0,0);
			
			// pred_vec = await run_group_together(image, model, pred_vec);
			await model.classify(image).then(predictions => { outp.innerHTML += predictions[0].className + " : " + predictions[0].probability + "<br/>"; pred_vec.push([predictions[0].className, predictions[0].probability]); });

			
        };  // end of image.onload

	// Way 1:
	image.src = url;

	});  // end of image.forEach

   });  // mobilenet.load()


    outp.innerHTML += 'pred_vec: ' + pred_vec + "<br/>";
	  
    // Save array to csv and download csv file
    downloadCSV(pred_vec);
	  
	  
}  // end of run_mobilenet
	
  // -------------------------------------------------

  function downloadCSV(pred_vec) {
	  
    const filename = 'data.csv';
    const link = document.createElement("a");

    outp.innerHTML += 'link: ' + link.download + "<br/>";
	  
    // if (link.download !== undefined) {

	// ---------------------
	// Puts array into csv format
	// const blob = new Blob([pred_vec], { type: 'text/csv;charset=utf-8;' });

	// Create a url for the data object
	//  const url = URL.createObjectURL(blob);
	// ---------------------
	// OR
	// ---------------------
	// Puts array into csv format
	let csvContent = "data:text/csv; charset=utf-8";
	pred_vec.forEach(function(row_array) {
		csvContent += row_array.join(",") + "\r\n";
	});
	// Create a url for the data object
	var url = encodeURI(csvContent);
	// ---------------------
	
	link.setAttribute("href", url);
	link.setAttribute("download", filename);
	link.style.visibility = 'hidden';
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
    //}
	  
}

  // -------------------------------------------------


  async function run_group_together(image, model, pred_vec) {
	  
    // https://github.com/tensorflow/tfjs-models/tree/master/mobilenet
	  
    try {
	// ---------------------
	// For using an image input to mobilenet
	// ---------------------
	// await model.classify(image).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); 
	// OR
	// Just list the first prediction choice, use a tensor as input
	await model.classify(image).then(predictions => { outp.innerHTML += predictions[0].className + " : " + predictions[0].probability + "<br/>"; pred_vec.push([predictions[0].className, predictions[0].probability]); });
	    
	// ---------------------
	// For using a tensor input to mobilenet
	// ---------------------
	// Convert the image element to a tensor using fromPixels
	// var tensor_image = tf.browser.fromPixels(image); // This is size 224,224,3

	// View the largest pixel value
	// outp.innerHTML += tf.max(tensor_image) + "<br/>";
	
	// const eTensor = tensor_image.expandDims(0); // This is size 1,224,224,3
	// outp.innerHTML += eTensor.shape + "<br/>";
	// ---------------------
	    
	// await model.classify(eTensor).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); 
	// OR
	// Just list the first prediction choice, use a tensor as input
	// await model.classify(eTensor).then(predictions => { outp.innerHTML += predictions[0].className + " : " + predictions[0].probability + "<br/>"; pred_vec.push([predictions[0].className, predictions[0].probability]); });
	// OR
	// Print the first prediction choice, use an image as input
	// await mobilenet.load().then(model => {model.classify(eTensor).then(predictions => { outp.innerHTML += predictions[0].className + " : " + predictions[0].probability + "<br/>"; } ) });
	    
    } catch (error) {
      outp.innerHTML = error; 
    }

	  return pred_vec;
  } 

  
  // -------------------------------------------------
	
</script>
</body>
</html>
