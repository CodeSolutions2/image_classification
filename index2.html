<!DOCTYPE html>
<html>
<head></head>
<body>

  <!-- Automatic image classification/labeling webapp -->
  <!-- https://js.tensorflow.org/api/1.0.0/ -->
  <h1 style='text-align: center; margin-bottom: -35px;'>CodeSolution2 - Image labeling webapp: Read files from URL and output label</h1>
  <br><br>
        <button id="run_mobilenet_way1" onclick="run_mobilenet_way1()" style="display:block">run_mobilenet_way1</button>
	<br>
	
<div id="output" style="font-family:courier;font-size:24px;height:300px"></div>
  
<style>canvas {border: 1px solid black;}</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0"></script>

<script>

  // -------------------------------------------------
	
  const outp = document.getElementById('output');

  var url_vec = [];

  // -------------------------------------------------
	
async function get_urls_from_repo() {
	
  try {
	  
    const repoOwner = 'CodeSolutions2';
    const repoName = 'test_4_webapps';
    var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;
    //var options = {method : 'get', headers: headers, mode: 'no-cors'};
    await fetch(url).then(res => res.json()).then(data => {

    data.forEach(file => {
      if (file.type === 'file' && file.name.match(/.(jpg|jpeg|png|gif)$/i)) {
        
        //outp.innerHTML += "Filename=" + file.name + ", file url=" + file.download_url + "<br/>";
	url_vec.push(file.download_url);
      }
    });
  }).catch(error => { outp.innerHTML += error; });

  } catch (error) {
    outp.innerHTML = error;
  }

	return url_vec;
}


  // -------------------------------------------------

function create_dynamic_canvasElement() {
	
	// Create a canvas element
	var canvasElement = document.createElement('canvas');

	// Set the width and height of the canvas
	canvasElement.width = 224;
	canvasElement.height = canvasElement.width;
	      
	// Get the 2D rendering context of the canvas
	var ctx = canvasElement.getContext("2d");
	      
	// Add the canvas to the document body or any other desired element
	document.body.appendChild(canvasElement);

	return ctx;
}


  // -------------------------------------------------
	

//async function load_model(){

	// Did not work
 	// model = await mobilenet.load().then(model => { return model });
	// OR
	//return await mobilenet.load();
//}
//const model = load_model();
	//TypeError: model.classify is not a function
	
  // -------------------------------------------------

  async function run_mobilenet_way1() {

    // Load the model outside of loop, only classify in the for loop

    var url_vec = await get_urls_from_repo();

    // PRINT
    outp.innerHTML += 'url_vec: ' + url_vec + "<br/>";
	  
    // Load the model
    await mobilenet.load().then(model => {

    url_vec.forEach(function(url, index) {
        
        // ---------------------------
        // Create a canvas for first image
	var ctx = create_dynamic_canvasElement();
	
	// ---------------------------

        
	const image = new Image();

        // Add 'crossorigin' attribute to bypass insecure error
        image.crossOrigin = "anonymous";

        // PRINT
        // outp.innerHTML += 'image.complete: ' + image.complete + "<br/>";

        image.onload = async () => {
	
		        // Draw image on canvas
		        // canvasElement.style.display = "block";
		        ctx.drawImage(image, 0,0);

			// outp.innerHTML += "index: " + index + "<br/>";
			// console.log(index);

			// ---------------------------------------------------

			await run_group_together(image, model);

		
			// OR
		
			// ---------------------------------------------------
		        // Convert the image element to a tensor using fromPixels
			//  var tensor_image = tf.browser.fromPixels(image); // This is size 224,224,3

		        // this printed correctly
			// outp.innerHTML += tf.max(tensor_image) + "<br/>";
				
		        // const eTensor = tensor_image.expandDims(0).dataSync(); // This is size 1,224,224,3
			// outp.innerHTML += eTensor.shape + "<br/>";
		
				
		//await model.classify(eTensor).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); 
                 
                 // Load, then classify - maybe it takes too much time
		 // mobilenet.load().then(model => {model.classify(eTensor).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); });

		 // Load, then classify - maybe it takes too much time
		 // await mobilenet.load().then(model => {model.classify(eTensor).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); });
			
        };  // end of image.onload

	// Way 1:
	image.src = url;

	});  // end of image.forEach

   });  // mobilenet.load()

	  
}  // end of run_mobilenet_way1
	

  // -------------------------------------------------


  async function run_group_together(image, model) {

    try {
	// Convert the image element to a tensor using fromPixels
	var tensor_image = tf.browser.fromPixels(image); // This is size 224,224,3

	// this printed correctly
	outp.innerHTML += tf.max(tensor_image) + "<br/>";
				
	// const eTensor = tensor_image.expandDims(0).dataSync(); // This is size 1,224,224,3
	const eTensor = tensor_image.expandDims(0); // This is size 1,224,224,3
	outp.innerHTML += eTensor.shape + "<br/>";

	// Test if eTensor 
	// await model.classify(eTensor).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); 
	// OR
	// await model.classify(image).then(predictions => {for(var i = 0; i<predictions.length; i++){outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;} }); 
	// OR
	// OR
	// Just list the first prediction choice
	await model.classify(eTensor).then(predictions => { outp.innerHTML += predictions[0].className + " : " + predictions[0].probability + "<br/>"; });
	// OR
	// Just list the first prediction choice
	// await mobilenet.load().then(model => {model.classify(image).then(predictions => { outp.innerHTML += predictions[0].className + " : " + predictions[0].probability + "<br/>"; } ) });
	    
    } catch (error) {
      outp.innerHTML = error; 
    }
    
  } 

  
  // -------------------------------------------------
	
</script>
</body>
</html>
