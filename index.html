<!DOCTYPE html>
<html>
<head></head>
<body>
  
    <!-- <img id="img" src="https://storage.googleapis.com/images4download0/image2.png" style="display:block" width="224" height="224" /> -->
    <!-- <img id="img" src="apple.png" style="display:block" width="224" height="224" /> -->
    <!-- OR -->
    <input type="file" id="img_input" name="avatar" accept="image/png, image/jpeg">
    <!-- OR -->
    <!-- <canvas id="canvasId" width="224" height="224" style="display:block"></canvas> -->


    <button id="myBtn" onclick="load_image()">Run Selection</button>

    <div id="output" style="font-family:courier;font-size:24px;height:300px"></div>

    <textarea id="outData" rows="2" cols="70" placeholder="notification" style="display:block"></textarea>

    <textarea id="outData1" rows="2" cols="70" placeholder="notification" style="display:block"></textarea>


<style>
      canvas {
        border: 1px solid black;
      }
    </style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0"> </script> 

  
<script>
  // var canvasElement = document.getElementById("canvasId");
  // const ctx = canvasElement.getContext("2d");

  const outp = document.getElementById('output');

  // -------------------------------------------------

  async function load_image() {

    var IMAGE_SIZE = 224;
    
    // ----------------------

    try {

      // Get the input element
      var input = document.getElementById('img_input');

      // Create a new FileReader instance
      var reader = new FileReader();

      // Set up the onload event handler
      reader.onload = function() {
      // ----------------------

        // Load image on canvas: the canvas allows one to manipulate the image values as an array/matrix
        // Way 0
        // Throws an error without a trigger (can only load image with EventListener or onload)
        // image.addEventListener("load", (e) => { ctx.drawImage(image, 0,0); image.style.display = "none"; });
  
        // OR
  
        // Way 1
        const image = new Image();
  
        // image.src = "https://storage.googleapis.com/images4download0/image2.png";
        // image.src = "apple.png";
        image.src = "tomatoe.png";
  
        // This returns quickly
        // image.onload = () => ctx.drawImage(image, 0,0);
        // OR
        // This retuns slowly because it needs to return the Promise
        // image.onload = () => {ctx.drawImage(image, 0,0);}
        // OR
        // This uses the canvas again, with more settings
        // image.onload = function (){ctx.drawImage(image, 0,0);  image.style.display = "none"; 
        // Test if one has the image data
        // const imageData = ctx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE);
        // var normalArray = Array.prototype.slice.call(imageData);
        // const test0 = tf.tensor(normalArray);
        // document.getElementById("outData").innerHTML = tf.max(test0);}
        // OR
        
        image.onload = function (){
          // Convert the image element to a tensor using fromPixels
          var tensor = tf.browser.fromPixels(image);
          document.getElementById("outData").innerHTML = tf.max(tensor)
        };

      };

      // Read the contents of the input as a data URL
      reader.readAsDataURL(input.files[0]);
      

      // OR

      // Way 2
      // const image = new Image(IMAGE_SIZE, IMAGE_SIZE, 3); // Using optional size for image
      // image.onload = drawImageActualSize; // Draw when image has loaded

      // Load an image of intrinsic size (IMAGE_SIZE x IMAGE_SIZE) in CSS pixels
      // image.src = "apple.png";
      // image.src = "https://storage.googleapis.com/images4download0/image2.png";

      // image is an image object

      // ----------------------

      // This did not work
      // const tensor = tf.browser.fromPixels(image);

      // OR

      // Uncaught Error: pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was Uint8ClampedArray
      // Uint8ClampedArray means that values are from 0-255
      // const imageData = ctx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE).data;

      // Uncaught Error: pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was Array

      // Converting imageData in format Uint8Array to Uint32Array
      // Uncaught Error: pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was Uint32Array
      // const imageData1 = new Uint32Array(imageData);

      // Converting the imageData to Array format
      // var normalArray = Array.prototype.slice.call(imageData);

      // Tried converting the imageData but gave errors
      // const tensor = tf.browser.fromPixels(imageData1);

      // OR

      // Works
      // const tensor_image = tf.browser.fromPixels(canvasElement);
      // This is size 224,224,3

      // ----------------------

      // 200704
      // const test0 = tf.tensor(normalArray)

      // document.getElementById("outData1").innerHTML = test0;

      
      // Works!
      // const test1 = tf.zeros([1, IMAGE_SIZE, IMAGE_SIZE, 3])

      // ----------------------

      // const eTensor = tensor_image.expandDims(0);
      // This is size 1,224,224,3

      // ----------------------

      // return image

    } catch (error) {
      document.getElementById("outData").innerHTML = error; 
      // return error
    }
    
  }  // end of load_image
  
  // -------------------------------------------------

  async function retreive_image() {

    try {
      
      await load_image().then(imageObj => imageObj).then(imageObj => {

        // imageObj is 'HTMLImageElement'

        // ----------------------
        // Test if it has received the image
        const tensor_image = tf.browser.fromPixels(canvasElement);

        // OR

        // const tensor_image = tf.browser.fromPixels(imageObj);
        // IndexSizeError: Index or size is negative or greater than the allowed amount
        // Common causes for this I found were returning negative values or trying to draw the image to the canvas before the image is actually loaded. 
        // ----------------------

        const eTensor = tensor_image.expandDims(0);

        // ----------------------

        document.getElementById("outData").innerHTML = tf.max(tensor_image);

        // Give image to model
        mobilenet.load().then(model => {
      model.classify(eTensor).then(predictions => {
        for(var i = 0; i<predictions.length; i++){
          outp.innerHTML += "<br/>" + predictions[i].className + " : " + predictions[i].probability;
        }
        });
        });
      
      });


    } catch (error) {
      document.getElementById("outData").innerHTML = error
    }

    // -------------------------------------------------

  }


  // -------------------------------------------------




</script>
</body>
</html>
